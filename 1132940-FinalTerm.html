<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML åœæ£‹éŠæˆ²ï¼ˆé›™ Pass è‡ªå‹•çµ‚å±€ï¼‰</title>
    <style>
        /* å®šç¾©æ£‹ç›¤å¤§å°å’Œå–®å…ƒæ ¼å°ºå¯¸ */
        :root {
            --board-size: 9; /* æ£‹ç›¤æ ¼æ•¸ (ä¾‹å¦‚ 9x9) */
            --cell-size: 40px; /* æ¯å€‹äº¤é»é–“çš„è·é›¢ */
            --board-total: calc(var(--board-size) - 1); /* ç¸½é–“éš”æ•¸ */
            --board-width: calc(var(--board-total) * var(--cell-size));
        }

        /* æ•´é«”ä½ˆå±€ */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f4;
            padding: 20px;
        }

        #game-container {
            display: flex;
            gap: 40px;
            margin-top: 20px;
        }

        /* --- æ£‹ç›¤ç¹ªè£½ï¼šç¢ºä¿æ ¼ç·šå¯è¦‹ --- */
        #board-wrapper {
            position: relative;
            /* é‚Šç•Œç·šéœ€è¦é¡å¤–ç©ºé–“ */
            width: calc(var(--board-width) + var(--cell-size) * 2); 
            height: calc(var(--board-width) + var(--cell-size) * 2);
            background-color: #deb887; /* æœ¨è‰² */
            border: 1px solid #333;
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.2);
        }

        /* ç¹ªè£½ç·šæ¢ */
        .line {
            position: absolute;
            background-color: #333;
            z-index: 5; 
        }

        /* å‚ç›´ç·š */
        .v-line {
            width: 1px;
            top: var(--cell-size); 
            bottom: var(--cell-size); 
        }

        /* æ°´å¹³ç·š */
        .h-line {
            height: 1px;
            left: var(--cell-size); 
            right: var(--cell-size); 
        }

        /* æ£‹å­å®¹å™¨ (äº¤é») */
        .intersection {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            transform: translate(-50%, -50%); 
            cursor: pointer;
            z-index: 10; 
        }

        /* æ£‹å­ */
        .stone {
            position: absolute;
            width: 36px; 
            height: 36px;
            border-radius: 50%;
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .black { background-color: #000; }
        .white { background-color: #fff; border: 1px solid #999; }
        
        .waiting { pointer-events: none; }

        /* --- è³‡è¨Šé¢æ¿ --- */
        #info-panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 250px;
            height: fit-content;
        }
        
        /* å‹å±€ç´€éŒ„å€å¡Š */
        #overall-scores {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #333; 
        }
        #overall-scores h3 { margin-top: 0; color: #444; }


        #scores {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #ccc;
        }

        #scores p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        #turn {
            font-weight: bold;
            margin-bottom: 15px;
        }

        .button-group button {
            padding: 10px 15px;
            margin-right: 10px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
            width: 100%;
        }

        #pass-btn { background-color: #f39c12; color: white; }
        #pass-btn:hover { background-color: #e67e22; }

        #restart-btn { background-color: #4CAF50; color: white; }
        #restart-btn:hover { background-color: #45a049; }

        #refresh-score-btn { background-color: #008CBA; color: white; }
        #refresh-score-btn:hover { background-color: #007bb5; }
    </style>
</head>
<body>

    <h1>åœæ£‹éŠæˆ²ï¼ˆé›™ Pass è‡ªå‹•çµ‚å±€èˆ‡å‹å±€ç´€éŒ„ï¼‰</h1>

    <div id="game-container">
        <div id="board-wrapper">
            </div>
        

        <div id="info-panel">
            
            <div id="overall-scores">
                <h3>ğŸ† å‹å±€ç´€éŒ„</h3>
                <p>ç©å®¶ï¼ˆé»‘æ£‹ï¼‰ï¼š<span id="black-wins">0</span> å±€</p>
                <p>é›»è…¦ï¼ˆç™½æ£‹ï¼‰ï¼š<span id="white-wins">0</span> å±€</p>
            </div>

            <h2>æœ¬å±€è³‡è¨Š</h2>

            <div id="scores">
                <h3>æå­ç´€éŒ„</h3>
                <p>é»‘æ£‹ï¼ˆç©å®¶ï¼‰æå­æ•¸ï¼š<span id="black-captures">0</span></p>
                <p>ç™½æ£‹ï¼ˆé›»è…¦ï¼‰æå­æ•¸ï¼š<span id="white-captures">0</span></p>
            </div>

            <p id="turn">è¼ªåˆ°ï¼š<span id="current-player">é»‘æ£‹</span></p>
            <p id="message"></p>

            <div class="button-group">
                <button id="pass-btn">Pass (ä¸è½å­)</button>
                <button id="restart-btn">å¼·åˆ¶é‡æ–°é–‹å§‹</button>
                <button id="refresh-score-btn">å¼·åˆ¶è¨ˆåˆ†</button>
            </div>
        </div>
    </div>
    <script>
        const BOARD_SIZE = 9;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;
        const CELL_SIZE = 40; 
        const AI_DELAY = 1; // 1 æ¯«ç§’å»¶é²ï¼Œé›»è…¦æ¥µé€Ÿä¸‹æ£‹

        let board = [];
        let currentPlayer = BLACK;
        let blackCaptures = 0;
        let whiteCaptures = 0;
        let previousBoardState = null;
        let isWaitingForAI = false; 
        let passCount = 0; // é€£çºŒ Pass æ¬¡æ•¸
        // å¾ localStorage è®€å–å‹å±€ç´€éŒ„ï¼Œå¦‚æœæ²’æœ‰å‰‡å¾ 0 é–‹å§‹
        let gameScore = JSON.parse(localStorage.getItem('goGameScore')) || { black: 0, white: 0 }; 

        const boardWrapper = document.getElementById('board-wrapper');
        const turnElement = document.getElementById('current-player');
        const messageElement = document.getElementById('message');
        const blackCapturesElement = document.getElementById('black-captures');
        const whiteCapturesElement = document.getElementById('white-captures');
        const blackWinsElement = document.getElementById('black-wins'); 
        const whiteWinsElement = document.getElementById('white-wins'); 
        const passButton = document.getElementById('pass-btn');

        // --- åˆå§‹åŒ–éŠæˆ² ---
        function initializeGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
            currentPlayer = BLACK;
            blackCaptures = 0;
            whiteCaptures = 0;
            previousBoardState = null;
            isWaitingForAI = false;
            passCount = 0; 
            renderBoard();
            updateInfo();
            messageElement.textContent = "é»‘æ£‹ï¼ˆç©å®¶ï¼‰å…ˆæ‰‹ï¼Œè«‹è½å­ï¼";
            passButton.disabled = false;
        }

        // --- æ¸²æŸ“æ£‹ç›¤ (ç¶­æŒä¸è®Š) ---
        function renderBoard() {
            boardWrapper.innerHTML = '';
            
            boardWrapper.style.setProperty('--board-size', BOARD_SIZE);
            boardWrapper.style.setProperty('--cell-size', `${CELL_SIZE}px`);
            
            boardWrapper.classList.toggle('waiting', isWaitingForAI);

            for (let i = 0; i < BOARD_SIZE; i++) {
                // æ°´å¹³ç·š
                const hLine = document.createElement('div');
                hLine.className = 'line h-line';
                hLine.style.top = `${i * CELL_SIZE + CELL_SIZE}px`;
                boardWrapper.appendChild(hLine);

                // å‚ç›´ç·š
                const vLine = document.createElement('div');
                vLine.className = 'line v-line';
                vLine.style.left = `${i * CELL_SIZE + CELL_SIZE}px`;
                boardWrapper.appendChild(vLine);
            }
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    
                    intersection.style.top = `${r * CELL_SIZE + CELL_SIZE}px`;
                    intersection.style.left = `${c * CELL_SIZE + CELL_SIZE}px`;

                    intersection.dataset.row = r;
                    intersection.dataset.col = c;
                    // åœ¨ AI ç­‰å¾…æ™‚ç¦ç”¨é»æ“Šäº‹ä»¶
                    if (!isWaitingForAI) {
                        intersection.addEventListener('click', () => handleMove(r, c));
                    }


                    if (board[r][c] !== EMPTY) {
                        const stone = document.createElement('div');
                        stone.className = `stone ${board[r][c] === BLACK ? 'black' : 'white'}`;
                        intersection.appendChild(stone);
                    }
                    boardWrapper.appendChild(intersection);
                }
            }
        }
        
        // --- æ ¸å¿ƒè¼”åŠ©å‡½æ•¸ (ç¶­æŒä¸è®Š) ---
        function findGroup(r, c, color, visited) {
            const liberties = new Set();
            const stones = [];
            const stack = [[r, c]];
            visited[r][c] = true;

            while (stack.length > 0) {
                const [currR, currC] = stack.pop();
                stones.push(`${currR},${currC}`);

                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    const newR = currR + dr;
                    const newC = currC + dc;

                    if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
                        if (board[newR][newC] === EMPTY) {
                            liberties.add(`${newR},${newC}`);
                        } else if (board[newR][newC] === color && !visited[newR][newC]) {
                            visited[newR][newC] = true;
                            stack.push([newR, newC]);
                        }
                    }
                });
            }
            return { liberties, stones };
        }

        function getLiberties(r, c, currentBoard) {
            const color = currentBoard[r][c];
            if (color === EMPTY) return 0;

            const visited = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(false));
            const liberties = new Set();
            const stack = [[r, c]];
            visited[r][c] = true;

            while (stack.length > 0) {
                const [currR, currC] = stack.pop();

                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    const newR = currR + dr;
                    const newC = currC + dc;

                    if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
                        if (currentBoard[newR][newC] === EMPTY) {
                            liberties.add(`${newR},${newC}`);
                        } else if (currentBoard[newR][newC] === color && !visited[newR][newC]) {
                            visited[newR][newC] = true;
                            stack.push([newR, newC]);
                        }
                    }
                });
            }
            return liberties.size;
        }

        function captureStones(r, c, targetBoard) {
            const opponentColor = (targetBoard[r][c] === BLACK) ? WHITE : BLACK;
            let captures = 0;

            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                const newR = r + dr;
                const newC = c + dc;

                if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
                    if (targetBoard[newR][newC] === opponentColor) {
                        if (getLiberties(newR, newC, targetBoard) === 0) {
                            const visited = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(false));
                            const { stones } = findGroup(newR, newC, opponentColor, visited);

                            stones.forEach(coord => {
                                const [sr, sc] = coord.split(',').map(Number);
                                targetBoard[sr][sc] = EMPTY;
                                captures++;
                            });
                        }
                    }
                }
            });

            return captures;
        }
        
        // **********************************************
        // é›»è…¦ AI é‚è¼¯ (Pass åˆ¤å®š)
        // **********************************************

        function computerMove() {
            if (currentPlayer !== WHITE) return;
            
            isWaitingForAI = true;
            renderBoard(); 

            const legalMoves = [];
            const captureMoves = []; 
            const computerColor = WHITE;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === EMPTY) {
                        const newBoard = JSON.parse(JSON.stringify(board));
                        newBoard[r][c] = computerColor;
                        
                        const capturedCount = captureStones(r, c, newBoard);
                        
                        const isSuicide = (capturedCount === 0 && getLiberties(r, c, newBoard) === 0);
                        if (isSuicide) continue; 

                        const newBoardState = JSON.stringify(newBoard);
                        if (newBoardState === previousBoardState) continue; 

                        if (capturedCount > 0) {
                            captureMoves.push({ r, c, captures: capturedCount });
                        }
                        legalMoves.push({ r, c });
                    }
                }
            }

            let finalMove = null;

            if (captureMoves.length > 0) {
                // å„ªå…ˆé¸æ“‡æå­æ•¸æœ€å¤šçš„é»
                captureMoves.sort((a, b) => b.captures - a.captures);
                finalMove = captureMoves[0];
            } else if (legalMoves.length > 0) {
                // éš¨æ©Ÿé¸æ“‡ä¸€å€‹åˆæ³•ç§»å‹•
                const randomIndex = Math.floor(Math.random() * legalMoves.length);
                finalMove = legalMoves[randomIndex];
            }

            if (finalMove) {
                // æ‰¾åˆ°è½å­é»ï¼šé‡ç½® Pass è¨ˆæ•¸ï¼ŒåŸ·è¡Œè½å­
                passCount = 0; 
                rawMove(finalMove.r, finalMove.c); 
            } else {
                // æ‰¾ä¸åˆ°è½å­é»ï¼šé¸æ“‡ Pass
                handlePass();
                messageElement.textContent = "é›»è…¦ (ç™½æ£‹) ç„¡è™•å¯ä¸‹ï¼Œé¸æ“‡ Passã€‚";
            }
        }
        
        // **********************************************
        // çµ±ä¸€è½å­/Pass è™•ç†å‡½æ•¸
        // **********************************************
        
        // è™•ç†è½å­
        function rawMove(r, c) {
            
            const playerColor = currentPlayer;
            
            const newBoard = JSON.parse(JSON.stringify(board)); 
            newBoard[r][c] = playerColor; 

            const capturedCount = captureStones(r, c, newBoard);
            
            if (playerColor === BLACK) {
                blackCaptures += capturedCount;
            } else {
                whiteCaptures += capturedCount;
            }

            board = newBoard;
            previousBoardState = JSON.stringify(board);

            passCount = 0; // **è½å­å‰‡é‡ç½® Pass è¨ˆæ•¸**

            currentPlayer = (playerColor === BLACK) ? WHITE : BLACK;

            isWaitingForAI = false; 
            renderBoard();
            updateInfo();
            
            if (playerColor === BLACK) {
                messageElement.textContent = `ç©å®¶ï¼ˆé»‘æ£‹ï¼‰æˆåŠŸè½å­åœ¨ (${r+1}, ${c+1})ï¼Œæå­ ${capturedCount} å€‹ã€‚`;
                messageElement.textContent += " è¼ªåˆ°é›»è…¦ï¼ˆç™½æ£‹ï¼‰æ€è€ƒ...";
                setTimeout(computerMove, AI_DELAY); 
            } else {
                messageElement.textContent = `é›»è…¦ï¼ˆç™½æ£‹ï¼‰æˆåŠŸè½å­åœ¨ (${r+1}, ${c+1})ï¼Œæå­ ${capturedCount} å€‹ã€‚è¼ªåˆ°ç©å®¶ï¼ˆé»‘æ£‹ï¼‰ã€‚`;
            }
        }
        
        // è™•ç† Pass é‚è¼¯ (å¯¦ç¾é€£çºŒå…©æ¬¡ Pass çµ‚å±€)
        function handlePass() {
            // 1. å¢åŠ  Pass è¨ˆæ•¸
            passCount++;

            // 2. **æª¢æŸ¥æ˜¯å¦é€£çºŒå…©æ¬¡ Pass çµæŸéŠæˆ²**
            if (passCount >= 2) {
                messageElement.textContent = "é›™æ–¹é€£çºŒ Passï¼ŒéŠæˆ²çµæŸï¼é–‹å§‹è¨ˆåˆ†ã€‚";
                passButton.disabled = true;
                isWaitingForAI = true; 
                calculateScore(true); // å‚³å…¥ true è¡¨ç¤ºé€™æ˜¯è‡ªå‹•çµæŸè¨ˆåˆ†
                return;
            }
            
            // 3. é€²è¡Œç‹€æ…‹æ›´æ–°å’Œåˆ‡æ›
            const playerColor = currentPlayer;
            currentPlayer = (playerColor === BLACK) ? WHITE : BLACK;
            isWaitingForAI = false; 
            updateInfo();
            renderBoard(); 
            
            if (playerColor === BLACK) {
                messageElement.textContent = "ç©å®¶ï¼ˆé»‘æ£‹ï¼‰é¸æ“‡ Passã€‚è¼ªåˆ°é›»è…¦ï¼ˆç™½æ£‹ï¼‰ã€‚";
                messageElement.textContent += " é›»è…¦ï¼ˆç™½æ£‹ï¼‰æ€è€ƒä¸­...";
                setTimeout(computerMove, AI_DELAY); 
            } else {
                messageElement.textContent = "é›»è…¦ï¼ˆç™½æ£‹ï¼‰é¸æ“‡ Passã€‚è¼ªåˆ°ç©å®¶ï¼ˆé»‘æ£‹ï¼‰ã€‚";
            }
        }

        // ç©å®¶é»æ“Šè™•ç†å‡½æ•¸ (ç¶­æŒä¸è®Š)
        function handleMove(r, c) {
            if (isWaitingForAI || currentPlayer === WHITE) {
                messageElement.textContent = "è«‹ç­‰å¾…ç™½æ£‹ï¼ˆé›»è…¦ï¼‰è½å­ï¼";
                return;
            }

            if (board[r][c] !== EMPTY) {
                messageElement.textContent = "æ­¤äº¤é»å·²æœ‰æ£‹å­ï¼";
                return;
            }

            // æª¢æŸ¥åˆæ³•æ€§ (è‡ªæ®ºå’ŒåŠ«çˆ­)
            const newBoard = JSON.parse(JSON.stringify(board)); 
            newBoard[r][c] = currentPlayer;

            const capturedCount = captureStones(r, c, newBoard);
            if (capturedCount === 0 && getLiberties(r, c, newBoard) === 0) {
                messageElement.textContent = "ç¦æ­¢è‡ªæ®ºï¼è«‹ä¸‹åœ¨æœ‰æ°£çš„ä½ç½®ã€‚";
                return;
            }

            const newBoardState = JSON.stringify(newBoard);
            if (newBoardState === previousBoardState) {
                messageElement.textContent = "ç¦æ­¢æ‰“åŠ«ï¼æ­¤ç‚ºé‡è¤‡å±€é¢ã€‚";
                return;
            }
            
            isWaitingForAI = true; 
            rawMove(r, c);
        }

        // --- ä»‹é¢æ›´æ–°èˆ‡äº‹ä»¶è™•ç† ---

        function updateInfo() {
            turnElement.textContent = (currentPlayer === BLACK) ? 'é»‘æ£‹ï¼ˆç©å®¶ï¼‰' : 'ç™½æ£‹ï¼ˆé›»è…¦ï¼‰';
            blackCapturesElement.textContent = blackCaptures;
            whiteCapturesElement.textContent = whiteCaptures;
            blackWinsElement.textContent = gameScore.black; 
            whiteWinsElement.textContent = gameScore.white; 
        }
        
        // Pass æŒ‰éˆ•äº‹ä»¶
        passButton.addEventListener('click', function() {
            if (currentPlayer === BLACK && !isWaitingForAI) {
                handlePass();
            } else if (isWaitingForAI) {
                messageElement.textContent = "è«‹ç­‰å¾…é›»è…¦è½å­ï¼";
            } else {
                 messageElement.textContent = "ç›®å‰è¼ªåˆ°é›»è…¦ï¼ˆç™½æ£‹ï¼‰è½å­ã€‚";
            }
        });

        document.getElementById('refresh-score-btn').addEventListener('click', () => {
            if (confirm("ç¢ºå®šè¦å¼·åˆ¶è¨ˆåˆ†å—ï¼Ÿå¼·åˆ¶è¨ˆåˆ†çš„çµæœä¸æœƒè¨ˆå…¥å‹å±€ç´€éŒ„ã€‚")) {
                calculateScore(false); // å‚³å…¥ false è¡¨ç¤ºéçµ‚å±€è¨ˆåˆ†
            }
        }); 

        document.getElementById('restart-btn').addEventListener('click', function() {
            if (confirm("ç¢ºå®šè¦å¼·åˆ¶çµæŸæœ¬å±€ä¸¦é‡æ–°é–‹å§‹å—ï¼Ÿæœ¬å±€çµæœå°‡ä¸è¨ˆå…¥å‹å±€ç´€éŒ„ã€‚")) {
                initializeGame();
            }
        });

        // --- æœ€çµ‚å‹è² åˆ¤å®šèˆ‡è¨ˆåˆ† ---

        function calculateScore(isFinal) {
            let blackScore = blackCaptures;
            let whiteScore = whiteCaptures;
            const visited = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(false));

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === BLACK) {
                        blackScore++; 
                    } else if (board[r][c] === WHITE) {
                        whiteScore++; 
                    } else if (board[r][c] === EMPTY && !visited[r][c]) {
                        const territoryResult = findTerritory(r, c, visited);
                        
                        if (territoryResult.isBlack) {
                            blackScore += territoryResult.count;
                        } else if (territoryResult.isWhite) {
                            whiteScore += territoryResult.count;
                        }
                    }
                }
            }

            // è²¼ç›®ï¼ˆKomiï¼‰: ç™½æ£‹è²¼ 6.5 ç›®
            whiteScore += 6.5;

            let winnerMessage = "";
            let winner = EMPTY;
            
            if (blackScore > whiteScore) {
                winnerMessage = `é»‘æ£‹ï¼ˆç©å®¶ï¼‰å‹åˆ©ï¼ç¸½åˆ†ï¼šé»‘ ${blackScore} vs. ç™½ ${whiteScore} (+6.5è²¼ç›®)ã€‚`;
                winner = BLACK;
            } else if (whiteScore > blackScore) {
                winnerMessage = `ç™½æ£‹ï¼ˆé›»è…¦ï¼‰å‹åˆ©ï¼ç¸½åˆ†ï¼šé»‘ ${blackScore} vs. ç™½ ${whiteScore} (+6.5è²¼ç›®)ã€‚`;
                winner = WHITE;
            } else {
                winnerMessage = `å¹³å±€ï¼ç¸½åˆ†ï¼šé»‘ ${blackScore} vs. ç™½ ${whiteScore} (+6.5è²¼ç›®)ã€‚`;
            }
            
            // å¦‚æœæ˜¯æœ€çµ‚è¨ˆåˆ† (é›™ Pass è‡ªå‹•çµæŸæˆ–ç©å®¶ä¸»å‹•é¸æ“‡çµæŸ)
            if (isFinal) {
                if (winner === BLACK) {
                    gameScore.black++;
                } else if (winner === WHITE) {
                    gameScore.white++;
                }
                // å°‡å‹å±€ç´€éŒ„å„²å­˜åˆ°ç€è¦½å™¨ (å¯é¸ï¼Œç”¨æ–¼åˆ·æ–°é é¢å¾Œä¿æŒç´€éŒ„)
                localStorage.setItem('goGameScore', JSON.stringify(gameScore)); 

                updateInfo(); 

                alert(`--- æœ€çµ‚è¨ˆåˆ†çµæœ (é›™ Pass çµæŸ) --- \n\n${winnerMessage}\n\næœ¬å±€çµæŸï¼Œè«‹é»æ“Šç¢ºå®šé–‹å§‹ä¸‹ä¸€å±€ã€‚`);
                initializeGame(); // **è‡ªå‹•é–‹å§‹ä¸‹ä¸€å±€**
            } else {
                // å¼·åˆ¶è¨ˆåˆ†æ™‚åªé¡¯ç¤ºçµæœï¼Œä¸è¨ˆå…¥å‹å±€
                alert(`--- å¼·åˆ¶è¨ˆåˆ†çµæœ --- \n\n${winnerMessage}\n\nçµæœä¸è¨ˆå…¥å‹å±€ç´€éŒ„ã€‚`);
            }

            messageElement.textContent = winnerMessage;
        }
        
        // åœ°ç›¤è¨ˆç®—è¼”åŠ©å‡½æ•¸ (ç¶­æŒä¸è®Š)
        function findTerritory(r, c, visited) {
            const stack = [[r, c]];
            visited[r][c] = true;
            let count = 0;
            let isBlack = true; 
            let isWhite = true; 

            while (stack.length > 0) {
                const [currR, currC] = stack.pop();
                count++;

                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    const newR = currR + dr;
                    const newC = currC + dc;

                    if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE) {
                        if (board[newR][newC] === EMPTY && !visited[newR][newC]) {
                            visited[newR][newC] = true;
                            stack.push([newR, newC]);
                        } else if (board[newR][newC] === BLACK) {
                            isWhite = false; 
                        } else if (board[newR][newC] === WHITE) {
                            isBlack = false; 
                        }
                    }
                });
            }

            return { count, isBlack, isWhite };
        }

        // å•Ÿå‹•éŠæˆ²
        initializeGame();

    </script>
</body>
</html>